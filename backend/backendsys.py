import sys
from datetime import datetime
import random
import time
import threading
import pickle
import json
import os

import concurrent.futures

sys.path.append('..')

# from subsenario.utils import initialize_llm
from request import LLMAPI, StableDiffusion

from util.constant import INITIAL_DRAGON_EYE,INITIAL_PHONEIX_FEATURE,INITIAL_EXPERIENCE
from util.constant import TASK_DISTRIBUTION

from util.prompt import TASK_PROMPT, EQUIPMENT_PROMPT, SKILL_PROMPT, CUSTOM_PROMPT

from util.prompt import DM_PROMPT

from util.prompt import JUDGE_PROMPT, ACT_PROMPT


DEBUG = True

def debug_print(*args):
    if DEBUG:
        for a in args:
            print(a)

def fixResponse(origin_text: str, attr: str):
    """
    Fix the response by removing all the \n to '\n'. A better way to fix this is to change the prompt.

    Args:
        origin_text (str): the origin text generated by the LLMs.
        attr (str): the attribution whose value need to be fixed.

    Returns:
        str: the fixed text.
    """
    
    index = origin_text.find(attr)
    if index == -1:
        return origin_text
    
    else:
        lquote = origin_text.find('"', index + len(attr) + 1)
        rquote = origin_text.find('"', lquote + 1)
        content = origin_text[lquote: rquote + 1]
        content = "\\n".join(content.split("\n"))
        text = origin_text[:lquote] + content + origin_text[rquote + 1:]

        return text

def initialize_llm(prompt, type="KIMI-server"):
    """
    instantiate the LLMAPI class.

    Args:
        prompt (str): the initial prompt for the LLMAPI.
        type (str, optional): the type of LLM, now support [gpt-3.5-turbo / kimi / KIMI-server]. Defaults to "KIMI-server".

    Returns:
        LLMAPI: the LLMAPI class.
    """
    # print("Initializing...")
    model = LLMAPI(model_name = type)
    intro = model.generateResponse(prompt, stream = True)
    return model

def read_file(prompt_name):
    """
    read the file name.
    ! deprecated soon.
    Args:
        prompt_name (str): the file name of the prompt stored.

    Returns:
        str: the content of the file.
    """
    with open(f"../prompts/{prompt_name}.txt", 'r', encoding='utf-8') as file:
        prompt = file.read()
    return prompt


class Player(object):
    """
    A class to gather all the information of the player.

    Attributes:
    ---
        - name (str): the name of the player.
        - email (str): the email of the player.
        - password (str): the encrypted password of the player.
        - feature (str): the feature of the player.
        - property (dict): the attributes of the player, including [Dragon Eye], [phoneix feature] and [experiments] so far.
        - personal_task_queue (dict): the personal task queue of the player.
        - bag (dict): the bag of the player, containing all the equipments.
        - skills (dict): the skills of the player, containing all the skills.
        - custom_tasks (list): the custom tasks of the player.

        - dm_model (LLMAPI): The DM LLM assigned to the player.
        - task_focus (bool): whether the player is focusing on a task.
        - current_task (str): the current task the player is focusing on.
        - task_director (LLMAPI): The task director LLM assigned to the player temporarily.
        - task_judge (LLMAPI): The task judge LLM assigned to the player temporarily.

    Methods:
    ---
        - takeTask()
        - leaveTask()
        - talkToDM()
        - talkToDirector()
        - getReward()
        - consumeProperty()
        - organizePlayerUse()
    """

    def __init__(self, 
                name: str, 
                email: str, 
                password: str, 
                DM_model: LLMAPI):
        
        self.name    : str = name
        self.email   : str = email
        self.password: str = password
        self.feature : str = "【苍穹】大陆上的游戏角色，目前是一个健全的人"
        self.property: dict = {
            "龙眼"  : INITIAL_DRAGON_EYE,
            "凤羽"  : INITIAL_PHONEIX_FEATURE,
            "经验值": INITIAL_EXPERIENCE,
        }

        # The DM assigned.
        self.dm_model      : LLMAPI  = DM_model
        self.task_director : LLMAPI  = None
        self.task_judge    : LLMAPI = None
        self.task_focus    : bool   = False
        self.current_task  : str    = None

        # 玩家的个性化任务
        self.personal_task_queue: dict = {}
        self.bag                : dict = {}
        self.skills             : dict = {}

    def takeTask(self, 
                task_director: LLMAPI,
                judge        : LLMAPI,
                task_name    : str)  : 
        """
        Take a task.

        To take a task, the user will be assigned to a director and a judge. furthermore, the user will change the focus to the task, so not to take multiple task at the same time.

        Args:
            task_director (LLMAPI): the LLM to direct the task.
            judge (LLMAPI): the LLM to judge the player's action.
            task_name (str): to indicate which task the player is taking.

        ? Do I have a better Implementation?
        """
        # assign LLM
        self.task_director = task_director
        self.task_judge    = judge
        # change focus
        self.task_focus    = True
        self.current_task  = task_name

    def leaveTask(self):
        """
        Leave the current task, and make settlements.

        To leave a task, the user will release the LLM assigned to the task, and change the focus back to the DM. The task name will be returned to free the task in task_queue.

        Returns:
            str: the task name.
        """
        # release LLM
        self.task_director = None
        self.task_judge = None
        # change focus
        self.task_focus = False
        task_name = self.current_task
        self.current_task = None

        return task_name

    def talkToDM(self, player_input: str):
        """
        based on the input to generate a response.

        Args:
            player_input (str): the user input.

        Returns:
            dict{}: the response from DM.
        """
        debug_print("conversation with DM")

        response = self.dm_model.generateResponse(f'【玩家】{player_input}')
        debug_print(response)
        response = json.loads(response)

        return response

    def talkToDirector(self, 
                        player_input: str,
                        player_use  : dict): 
        """
        
        Talk to the task_director.

        Args:
            player_input (str): the latest input of the player.
            player_use (dict): the available 'things' of player.

        Returns:
            dict{}: the response from task_director.
            dict{}: the response from judge.
        """

        debug_print("conversation with task")

        system_words = self.task_director.getAllConversation()[-1]["content"]
        player_profile = self.property | {"character": self.feature} | {"use": player_use}

        play_infos = {
            "system": system_words,
            "player": player_input,
            "player_status": player_profile
        }

        # Check if the action is practical.
        content = json.dumps(play_infos, ensure_ascii=False)
        response = self.task_judge.generateResponse(content)
        judge = json.loads(response)

        task_play = {
            "player": player_input,
            "judge" : judge["judge"],
            "reason": judge["reason"]
        }

        # generate response from the director.
        content = json.dumps(task_play, ensure_ascii=False)
        response = self.task_director.generateResponse(content)
        response = fixResponse(response, "text")
        # ! What.. I say the prompt need to be fixed.
        if DEBUG:
            print('[judge]\n', response)
            print('=' * 10)
            print(content)
            print('[task]\n', response)
            with open("./debug.txt", "w", encoding='utf-8') as f:
                f.write(response)
            print('=' * 10)

        play = json.loads(response)

        return judge, play

    def getReward(self, rewards:dict):
        """
        Update the player's property based on the rewards.

        Args:
            rewards (dict): the information of rewards.
        """

        debug_print(rewards)

        if rewards == None or rewards == {}:
            return

        for k, v in rewards.items():
            if k in self.property:
                self.property[k] += v
            else:
                debug_print("Not presented attr {k}.")

    def consumeProperty(self, item:str, num:int):
        """
        Consume the property of the player.

        I believe a better way to do this is to return true or false...

        Args:
            item (str): the name of the property.
            num (int): the number of the property.

        Returns:
            bool: whether the player can afford the property. If true, then will comsume atomatically.
        """

        if self.property[item] < num:
            return False
        else:
            self.property[item] -= num
            return True

    def organizePlayerUse(self, 
                            equipment_list: list,
                            skill_list    : list): 
        """
        To find the equipment and skill that the player owns.

        Args:
            equipment_list (list)
            skill_list (list)

        Returns:
            dict: the result of the search.
            {
                "equipment": (List[dict]),
                "skill": (list[dict])
            }
        """
        result = {
            "equipment": list( set(equipment_list) & set(self.bag) ),
            "skill": list( set(skill_list) & set(self.skills) )
        }

        return result


class BackEndSystem(object):
    """
    The backend system of the game, mainly maintain the critical information of the game.
    Or really if so...

    Attributes:
    ---
        - task_generator (LLMAPI): the overall task generator.
        - equipment_generator (LLMAPI): the overall equipment generator.
        - skill_generator (LLMAPI): the overall skill generator.
        - task_custom (LLMAPI): the overall task custom generator.
        ! hint: this is not suitable for high freq use.
        - sd (StableDiffusion): The model to generate avatars and backgrounds.
        - task_queue (dict{}) the task information.

        - player_dict (dict{str:Player}): all the registered players.
        - player_dict2 (dict{str:Player}): all the players indexed by email.
        - online_player (dict{str:Player}): all the online players.


    Methods:
    ---
        - registerPlayer()
        - loginPlayer()
        _method3_ (type): _description_
    """

    def __init__(self, one_day_length_minutes=40):
        """
        Args:
            one_day_length_minutes (int, optional): How long a day in the game in minutes. Defaults to 40.
        """

        # task_prompt = read_file("task")
        # eq_prompt = read_file('equipment_craft')
        # sk_prompt = read_file('skill_generate')
        # custom_prompt = read_file('task_custom')


        # ? For what reason?
        # 以用户名为键值
        self.player_dict: dict[str:Player] = {}
        # 以邮箱为键值
        self.player_dict2: dict[str:Player] = {}
        # 当前在线玩家
        self.online_player: dict[str:Player] = {}

        # 各组件初始化

        def instantiate_llm(prompt:str, variable_name:str):
            return {variable_name: initialize_llm(prompt)}
        
        # with concurrent.futures.ProcessPoolExecutor(max_workers = 4) as executor:

        #     futures = []
        #     futures.append(executor.submit(instantiate_llm, TASK_PROMPT, "task_generator"))
        #     futures.append(executor.submit(instantiate_llm, EQUIPMENT_PROMPT, "equipment_generator"))
        #     futures.append(executor.submit(instantiate_llm, SKILL_PROMPT, "skill_generator"))
        #     futures.append(executor.submit(instantiate_llm, CUSTOM_PROMPT, "task_custom"))

        #     for future in concurrent.futures.as_completed(futures):
        #         result = future.result()
        #         self.__dict__.update(result)

        self.task_generator     : LLMAPI = initialize_llm(TASK_PROMPT)
        self.equipment_generator: LLMAPI = initialize_llm(EQUIPMENT_PROMPT)
        self.skill_generator    : LLMAPI = initialize_llm(SKILL_PROMPT)
        self.task_custom        : LLMAPI = initialize_llm(CUSTOM_PROMPT)

        # Why doing so?
        self.sd: StableDiffusion = StableDiffusion()
        self.sd.initialize()

        # 任务队列
        self.task_queue = {}


    def registerPlayer(self, name, email, password):
        """
        Add a new instance of Player in the DM.
        The name and the feature are firstly checked.
        ? Bro what are you doing?
        ! need double check.

        Args:
            name (str): The player name.
            email (str): The player email.
            password (str): The player password.

        Returns:
            bool: True if the registration is successful.
        """
        # ? What?
        if name in self.player_dict:
            return False
        if email in self.player_dict2:
            return False

        dm_model  : LLMAPI = initialize_llm(DM_PROMPT)
        new_player: Player  = Player(name, email, password, dm_model)

        # regist the user in the list.
        self.player_dict[name]   = new_player
        self.player_dict2[email] = new_player
        self.online_player[name] = new_player

        return True

    def loginPlayer(self, email, password):
        """
        Login the player by using email and password...


        Args:
            email (str): the email to indentify the player.
            password (str): the password to indentify the player.

        Returns:
            str|None: the player'name if login successfully, or none if failed.
        """
        if email not in self.player_dict2.keys():
            return None
        
        player: Player = self.player_dict2[email]

        if password != player.password:
            return None
        else:
            return player.name

    def refreshTaskQueue(self, num=3):
        """
        ? Why this name...
        Check and update the task queue, making the queue is full.

        Args:
            num (int, optional): the maximum task number. Defaults to 3.


        """
        task_type = list(TASK_DISTRIBUTION.keys())
        probabilities = list(TASK_DISTRIBUTION.values())

        # This really fucked up.
        for __ in range(num):
            chosen_item = random.choices(task_type, weights=probabilities, k=1)[0]
            task = self.taskGenerate(chosen_item)
            self.task_queue[task["task_name"]] = task

    def taskGenerate(self, 
                    task_type  : str,
                    description: str = "任意"): 
        """
        Generate a task based on the task type and description.

        Args:
            task_generator (LLMAPI): The task generator.
            task_type (str): the type of the task
            description (str, optional): The detailed description of the task. Defaults to "任意".

        Returns:
            dict{}: The information of generated task.
            {
                "task_name":（任务名称）
                "task_description":（任务描述)
                "attention":（注意事项）
                "reward":（任务报酬）
                "occupied":（是否被占用）
                "player":（占用者）
            }
        """
        need = f"帮我生成一个{description}的{task_type}"
        task = self.task_generator.generateResponse(need)
        task = json.loads(task)
        task["occupied"] = False
        task["player"] = None
        return task

    def taskCustomize(self, player_name, description="任意"):
        """
        Customize the task based on the description. Note that this task is private and not visible for other players.

        Args:
            player_name (str): the player name who asking the task.
            description (str, optional): the description of the task. Defaults to "任意".

        Returns:
            dict: the customized task information.
        """
        need = f"【玩家】帮我生成一个任务， 要求是{description}"
        task = self.task_custom.generateResponse(need)
        task = json.loads(task)

        player: Player = self.player_dict[player_name]
        player.personal_task_queue[task['task_name']] = task
        # return for what...
        return task

    def getPlayerInput(self, 
                        player_name : str,
                        player_input: str,
                        mode        : int,
                        equipment   : list = [],
                        skill       : list = [],
                        roles       : list = []): 
        """
        Get the player input and return the response from the system, including the dm and the director.

        Args:
            player_name (str): The name of the player.
            player_input (str): The input of the player.
            mode (int): the code to indicate the mode of the system. 
            0: Talking to DM.
            1: Talking to director.
            equipment (list, optional): The equipment of the player. Defaults to [].
            skill (list, optional): The skill of the player. Defaults to [].
            roles (list, optional): The previous NPCs appeared. Defaults to [].
        
        Returns:
            dict{}: the result from DM or director.

        Raises:
            ValueError: If the player is not found.

        ! How does writing like this helps...
        """
        debug_print(self.player_dict.keys())

        if player_name not in self.player_dict.keys():
            raise ValueError("Player not found")
        player: Player = self.player_dict[player_name]

        match mode:
            case 0:
                return player.talkToDM(player_input)
            case 1:
                # As you wish.
                player_use = player.organizePlayerUse(equipment, skill)
                judge, play = player.talkToDirector(player_input, player_use)
                debug_print('[debug]play:', judge, play)

                # Check if a new NPC appears. Say, generate a new NPC.
                if play["role"] and play["role"] not in roles:
                    debug_print("generating img...")
                    description = f"【场景】{play['text']}\n【需要描绘的角色】{play['role']}"
                    img = self.sd.standard_workflow(description, 1)
                    play["image_data"] = img

                # 游戏结束，进入结算
                elif play["status"] == 1:
                    task_name = player.leaveTask()
                    self.task_queue.pop(task_name)

                    rewards = play["reward"]
                    if rewards:
                        player.getReward(rewards)
                    play["image_data"] = None

                # 游戏正常进行且没有新角色
                else:
                    play["image_data"] = None

                return play

    def selectTask(self, player_name: str, task_name: str):
        """
        Args:
            player_name (str): the player's name who chose the task.
            task_name (str): the task's name which is chosen.

        ? How can you know this task is now yours? Weird.

        Returns:
            dict{}: the initial_scene generated by the director.

        Raises:
            ValueError: when the task is not avaliable.
        """

        debug_print(player_name, task_name)
        task = self.task_queue[task_name]
        # ? json.loads(task)
        play = str(task)

        task_img = self.sd.standard_workflow(play, 2)

        # if task["occupied"] == False:
        #     raise ValueError("This task is not available now")

        task["occupied"] = True
        task["player"] = player_name

        # judge_prompt = read_file("judge")
        # act_prompt = read_file("task_acting")

        judge        : LLMAPI = initialize_llm(JUDGE_PROMPT)
        task_director: LLMAPI = initialize_llm(ACT_PROMPT)

        initial_scene = task_director.generateResponse(play)
        initial_scene = json.loads(initial_scene)
        initial_scene['image_data'] = task_img

        debug_print('start>', initial_scene)

        player: Player = self.player_dict[player_name]
        player.takeTask(task_director, judge, task_name)

        return initial_scene

    def selectPersonalTask(self, player_name: str, task_name: str):
        """
        Args:
            player_name (str):
            task_name (str):

        Returns:
            bool: if the user selected the task.

        TODO This with the above might combine to one function.
        """

        debug_print(player_name, task_name)
        player: Player = self.player_dict[player_name]
        task = player.personal_task_queue[task_name]
        play = str(task)

        if task["occupied"] == False:
            raise ValueError("This task is not available now")
        
        task_img = self.sd.standard_workflow(play, 2)

        task["occupied"] = True
        task["player"] = player_name

        judge        : LLMAPI = initialize_llm(JUDGE_PROMPT)
        task_director: LLMAPI = initialize_llm(ACT_PROMPT)

        initial_scene: str = task_director.generateResponse(play)
        initial_scene = json.loads(initial_scene)
        initial_scene['image_data'] = task_img

        player: Player = self.player_dict[player_name]
        player.takeTask(task_director, judge, task_name)

        return initial_scene
        
    def getPlayerInfo(self, name):
        """
        To be exact, this returns the propoerty of the player.

        Args:
            name (str): the name of the player.

        Returns:
            dict{}: the property of the player.
        """
        if name in self.player_dict.keys():
            player: Player = self.player_dict[name]
            return player.property
        else:
            return None

    def craftItems(self, 
                    player_name: str, 
                    mode: int, 
                    num: int, 
                    description: str):
        """
        
        To finally make some items to use.

        Either craft equipment or skill, function will register the result, and consume the property.

        Args:
            player_name (str): the player who is about to craft.
            mode (int): 0 for equipment, 1 for skill.
            num (int): the number of resources the player is willing to use.
            description (str): the description of the expected item.

        Returns:
            str|dict: Neither the information of why failed, or the real information dict for equipment/skill
        """
        if player_name in self.player_dict.keys():
            player: Player = self.player_dict[player_name]

        if description == "":
            return "Error"

        if mode == 0:
            if player.consumeProperty('凤羽', num) == False:
                return "您的凤羽储量不足，请不要为难我，勇士！"
            
            request = f"{player_name}想要制作{description}的装备，对此玩家愿意投入 {num} 凤羽"
            response = self.equipment_generator.generateResponse(request)

            debug_print(response)

            response = fixResponse(response, "outlook")
            response = fixResponse(response, "description")
            equip = json.loads(response)
            player.bag[equip['name']] = equip
            return equip

        elif mode == 1:
            
            if player.consumeProperty('龙眼', num) == False:
                return "您的龙眼储量不足，请不要为难我，勇士！"
            
            request = f"【请求之人】{player_name} 需要一个{description}的技能，对此我愿意投入{num}个龙眼。"
            response = self.skill_generator.generateResponse(request)

            debug_print(response)

            skill = json.loads(response)
            response = fixResponse(response, "effect")
            player.skills[skill['name']] = skill

            return skill
        
        else:
            return "Unknown mode"

    def getAllAvailableTasks(self):
        """
        Return all the tasks that are available for public.

        Returns:
            List[str]: the result.
        """
        tasks = [task["task_name"] for task in self.task_queue.values() if task["occupied"] == False]

        return tasks

    def getAllAvailablePersonalTasks(self, player_name):
        """
        return all the tasks that are private, and also not occupied...

        Args:
            player_name (str): the player name...

        Returns:
            List[str]: the result.
        """
        player: Player = self.player_dict[player_name]
        tasks = [task["task_name"] for task in player.personal_task_queue.values()]

        return tasks
    
    def getAllOnlinePlayers(self):
        """
        Return all the online players.
        """

        result = list(self.online_player.keys())
        return result

    def checkOnlineState(self):
        """
        Update the online player list.
        TODO: Not implemented yet.
        """

        pass


# ! depracated soon. Didn't review.
class MultiThreadManager:
    def __init__(self, backend_sys: BackEndSystem, check_interval=600):
        self.backend_sys = backend_sys
        self.check_interval = check_interval

        self.threads = []
        self.running = True

        # 创建并启动任务监控线程
        monitor_thread = threading.Thread(target=self.refresh_task_queue)
        monitor_thread.start()
        self.threads.append(monitor_thread)

        # 创建并启动玩家信息保存线程
        player_thread = threading.Thread(target=self.save_player_info)
        player_thread.start()
        self.threads.append(player_thread)

    # 每隔600秒检查一次任务队列，如果小于3就会自动补充
    def refresh_task_queue(self, max_size=3):
        while self.running:
            existed_task_num = len(self.backend_sys.task_queue)
            if len(self.backend_sys.task_queue) < max_size:
                new_task_num = max_size - existed_task_num
                self.backend_sys.refreshTaskQueue(new_task_num)
                print(f"队列大小少于{max_size}，已添加{new_task_num}个元素。当前队列大小：{len(self.backend_sys.task_queue)}")
            time.sleep(self.check_interval)

    def save_player_info(self):
        while self.running:
            for name, info in self.backend_sys.online_player.items():
                
                if not os.path.isdir('./saves'):
                    os.makedirs('./saves')
                filename = f'./saves/{name}.pkl'
                with open(filename, 'wb') as file:
                    pickle.dump(info, file)
            time.sleep(self.check_interval)

    def stop(self):
        self.running = False
        for thread in self.threads:
            thread.join()



