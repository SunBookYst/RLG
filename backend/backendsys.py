import sys
from datetime import datetime, timedelta
import random
import time
import threading
import pickle
import json
import os

from request import LLMAPI, StableDiffusion
from request.constant import get_valid_headers

from util.constant import INITIAL_DRAGON_EYE, INITIAL_PHONEIX_FEATURE, INITIAL_EXPERIENCE, TASK_DISTRIBUTION

from util.prompt import (TASK_PROMPT, EQUIPMENT_PROMPT, SKILL_PROMPT, CUSTOM_PROMPT, DM_PROMPT, JUDGE_PROMPT,
                         ACT_PROMPT, BATTLE_PROMPT, SUM_PROMPT)

# TODO
# 玩家资源消耗问题


sys.path.append('..')


# debug模式
DEBUG = True
# 全局线程锁
LOCK = threading.Lock()


def debug_print(*args):
    if DEBUG:
        for a in args:
            print(a)


def fixResponse(origin_text: str, attr: str):
    """
    Fix the response by removing all the \n to '\n'. A better way to fix this is to change the prompt.

    Args:
        origin_text (str): the origin text generated by the LLMs.
        attr (str): the attribution whose value need to be fixed.

    Returns:
        str: the fixed text.
    """
    lindex = origin_text.find('{')
    rindex = origin_text.find('}')
    if lindex != -1 and rindex != -1:
        origin_text = origin_text[lindex: rindex+1]
    
    index = origin_text.find(attr)
    if index == -1:
        return origin_text
    
    else:
        lquote = origin_text.find('"', index + len(attr) + 1)
        rquote = origin_text.find('"', lquote + 1)
        content = origin_text[lquote: rquote + 1]
        content = "\\n".join(content.split("\n"))
        text = origin_text[:lquote] + content + origin_text[rquote + 1:]

        return text


def initialize_llm(prompt, type: str = "KIMI-server"):
    """
    instantiate the LLMAPI class.

    Args:
        prompt (str): the initial prompt for the LLMAPI.
        type (str, optional): the type of LLM, now support [gpt-3.5-turbo / kimi / KIMI-server]. Defaults to "KIMI-server".

    Returns:
        LLMAPI: the LLMAPI class.
    """
    # print("Initializing...")
    model = LLMAPI(model_name=type, headers=get_valid_headers())
    intro = model.generateResponse(prompt, stream=True)
    return model


class Player(object):
    """
    A class to gather all the information of the player.

    Attributes:
    ---
        - name (str): the name of the player.
        - email (str): the email of the player.
        - password (str): the encrypted password of the player.
        - feature (str): the feature of the player.
        - property (dict): the attributes of the player, including [Dragon Eye], [phoneix feature] and [experiments] so far.
        - personal_task_queue (dict): the personal task queue of the player.
        - bag (dict): the bag of the player, containing all the equipments.
        - skills (dict): the skills of the player, containing all the skills.
        - custom_tasks (list): the custom tasks of the player.

        - dm_model (LLMAPI): The DM LLM assigned to the player.
        - task_focus (bool): whether the player is focusing on a task.
        - current_task (str): the current task the player is focusing on.
        - task_director (LLMAPI): The task director LLM assigned to the player temporarily.
        - task_judge (LLMAPI): The task judge LLM assigned to the player temporarily.

    Methods:
    ---
        - takeTask()
        - leaveTask()
        - talkToDM()
        - talkToDirector()
        - getReward()
        - consumeProperty()
        - organizePlayerUse()
    """

    def __init__(self, 
                 name: str,
                 email: str,
                 password: str,
                 DM_model: LLMAPI,
                 eg_model: LLMAPI,
                 sg_model: LLMAPI,
                 tc_model: LLMAPI):
        
        self.name    : str = name
        self.email   : str = email
        self.password: str = password
        self.feature : str = "【苍穹】大陆上的游戏角色，目前是一个健全的人"
        self.property: dict = {
            "龙眼"  : INITIAL_DRAGON_EYE,
            "凤羽"  : INITIAL_PHONEIX_FEATURE,
            "经验值": INITIAL_EXPERIENCE,
        }

        # The DM assigned.
        self.dm_model           : LLMAPI = DM_model
        self.equipment_generator: LLMAPI = eg_model
        self.skill_generator    : LLMAPI = sg_model
        self.task_custom        : LLMAPI = tc_model

        self.task_director   : LLMAPI = None
        self.task_judge      : LLMAPI = None
        self.task_focus      : bool = False
        self.current_task    : str = None
        self.current_opponent: str = None

        # 玩家的个性化任务
        self.personal_task_queue: dict = {}
        self.bag                : dict = {}
        self.skills             : dict = {}

        # PVP
        self.challenge_queue: dict = {}

    def takeTask(self, 
                 task_director: LLMAPI,
                 judge        : LLMAPI,
                 task_name    : str):
        """
        Take a task.

        To take a task, the user will be assigned to a director and a judge. furthermore, the user will change the focus to the task, so not to take multiple task at the same time.

        Args:
            task_director (LLMAPI): the LLM to direct the task.
            judge (LLMAPI): the LLM to judge the player's action.
            task_name (str): to indicate which task the player is taking.

        ? Do I have a better Implementation?
        """
        # assign LLM
        self.task_director = task_director
        self.task_judge    = judge
        # change focus
        self.task_focus    = True
        self.current_task  = task_name

    def leaveTask(self):
        """
        Leave the current task, and make settlements.

        To leave a task, the user will release the LLM assigned to the task, and change the focus back to the DM. The task name will be returned to free the task in task_queue.

        Returns:
            str: the task name.
        """
        # release LLM
        self.task_director = None
        self.task_judge = None
        # change focus
        self.task_focus = False
        task_name = self.current_task
        self.current_task = None

        return task_name

    def talkToDM(self, player_input: str):
        """
        based on the input to generate a response.

        Args:
            player_input (str): the user input.

        Returns:
            dict{}: the response from DM.
        """
        debug_print("conversation with DM")

        response = self.dm_model.generateResponse(f'【玩家】{player_input}')
        debug_print(response)
        response = json.loads(response)

        return response

    def talkToDirector(self, 
                       player_input: str,
                       player_use  : dict):
        """
        
        Talk to the task_director.

        Args:
            player_input (str): the latest input of the player.
            player_use (dict): the available 'things' of player.

        Returns:
            dict{}: the response from task_director.
            dict{}: the response from judge.
        """

        debug_print("conversation with task")

        system_words = self.task_director.getAllConversation()[-1]["content"]
        player_profile = self.property | {"character": self.feature} | {"use": player_use}

        play_infos = {
            "system": system_words,
            "player": player_input,
            "player_status": player_profile
        }

        # Check if the action is practical.
        content = json.dumps(play_infos, ensure_ascii=False)
        response = self.task_judge.generateResponse(content)
        judge = json.loads(response)

        task_play = {
            "player": player_input,
            "judge" : judge["judge"],
            "reason": judge["reason"]
        }

        # generate response from the director.
        content = json.dumps(task_play, ensure_ascii=False)
        response = self.task_director.generateResponse(content)
        response = fixResponse(response, "text")
        # ! What.. I say the prompt need to be fixed.
        if DEBUG:
            print('[judge]\n', response)
            print('=' * 10)
            print(content)
            print('[task]\n', response)
            with open("./debug.txt", "w", encoding='utf-8') as f:
                f.write(response)
            print('=' * 10)

        play = json.loads(response)

        return judge, play

    def getReward(self, rewards: dict):
        """
        Update the player's property based on the rewards.

        Args:
            rewards (dict): the information of rewards.
        """

        debug_print(rewards)

        if not rewards or rewards == {}:
            return

        for k, v in rewards.items():
            if k in self.property:
                self.property[k] += v
            else:
                debug_print("Not presented attr {k}.")

    def consumeProperty(self, item: str, num: int):
        """
        Consume the property of the player.

        I believe a better way to do this is to return true or false...

        Args:
            item (str): the name of the property.
            num (int): the number of the property.

        Returns:
            bool: whether the player can afford the property. If true, then will comsume atomatically.
        """

        if self.property[item] < num:
            return False
        else:
            self.property[item] -= num
            return True

    def organizePlayerUse(self, 
                          equipment_list: list,
                          skill_list    : list):
        """
        To find the equipment and skill that the player owns.

        Args:
            equipment_list (list)
            skill_list (list)

        Returns:
            dict: the result of the search.
            {
                "equipment": (List[dict]),
                "skill": (list[dict])
            }
        """
        result = {
            "equipment": [self.bag[equip_name] for equip_name in equipment_list],
            "skill": [self.skills[skill_name] for skill_name in skill_list]
        }

        return result


class Battle(object):
    def __init__(self, player1, player2, player1_role, player2_role, battle_id):
        # 独特标识该战斗的id
        self.battle_id: str = battle_id
        # 战斗创建时间，便于清理超时挑战
        self.create_time: datetime = datetime.now()
        # 0：等待接受，1：已接受， 2：已拒绝， 3：正在进行， 4：已结束， 5：意外结束
        self.status: int = 0

        # 属于该战斗的系统
        self.sys: LLMAPI = None
        # 发起者
        self.challenger: str = player1
        self.challenger_role: Player = player1_role
        # 被挑战者
        self.target: str = player2
        self.target_role: Player = player2_role
        self.roles: dict = {player1: self.challenger_role, player2: self.target_role}
        # 玩家对，便于查找对手是谁
        self.pair: dict = {player1: player2, player2: player1}

        # 已经完成的上一回合战斗
        self.last_round: dict = {
            self.challenger: 0,
            self.target: 0,
            'details': {
                self.challenger: None, self.target: None, 'sys': None
            }
        }
        # 等待完成的新一回合战斗
        self.now_round: dict = {'details': {}}
        # 得分记录
        self.record: dict = {player1: 0, player2: 0}

    def directFight(self, player):
        if DEBUG:
            print("directing...")

        opponent = self.pair[player]
        # player是指触发该方法的player
        details = {
            self.challenger: {
                "action": self.now_round['details'][self.challenger]['action'],
                "status": self.now_round['details'][self.challenger]['status'],
            },
            self.target: {
                "action": self.now_round['details'][self.target]['action'],
                "status": self.now_round['details'][self.target]['status'],
            },
        }
        content = json.dumps(details, ensure_ascii=False)
        res = json.loads(self.sys.generateResponse(content))

        if DEBUG:
            print(res)

        if res['judge'] != "平局":
            self.record[res['judge']] += 1

        battle_status = False
        # 率先赢下5轮者获胜
        if self.record[opponent] == 1 or self.record[player] == 1:
            battle_status = True
            self.status = 4

            # 确定胜者和败者
            if self.record[opponent] == 1:
                winner = opponent
                loser = player
            else:
                winner = player
                loser = opponent

            self.settleBattle(winner, loser)
            res['description'] += f"【{winner}】赢得了胜利！"

        self.last_round = self.now_round
        self.last_round['details']['sys'] = res["description"]
        self.last_round[player] = 1  # 已阅
        self.last_round[self.pair[player]] = 0  # 未读

        self.now_round = {'details': {}}

        return res['description'], battle_status

    def settleBattle(self, winner, loser):
        res = json.loads(self.sys.generateResponse(SUM_PROMPT(winner, loser)))
        self.roles[winner].getReward(res[winner])
        self.roles[loser].getReward(res[loser])


class BackEndSystem(object):
    """
    The backend system of the game, mainly maintain the critical information of the game.
    Or really if so...

    Attributes:
    ---
        - task_generator (LLMAPI): the overall task generator.
        - equipment_generator (LLMAPI): the overall equipment generator.
        - skill_generator (LLMAPI): the overall skill generator.
        - task_custom (LLMAPI): the overall task custom generator.
        ! hint: this is not suitable for high freq use.
        - sd (StableDiffusion): The model to generate avatars and backgrounds.
        - task_queue (dict{}) the task information.

        - player_dict (dict{str:Player}): all the registered players.
        - player_dict2 (dict{str:Player}): all the players indexed by email.
        - online_player (dict{str:Player}): all the online players.


    Methods:
    ---
        - registerPlayer()
        - loginPlayer()
        _method3_ (type): _description_
    """

    def __init__(self, one_day_length_minutes=40):
        """
        Args:
            one_day_length_minutes (int, optional): How long a day in the game in minutes. Defaults to 40.
        """
        # ? For what reason?
        #　Ａ：一个用来登陆一个用来玩
        # 以用户名为键值
        self.player_dict: dict[str:Player] = {}
        # 以邮箱为键值
        self.player_dict2: dict[str:Player] = {}
        # 当前在线玩家
        self.online_player: dict[str:Player] = {}

        # 各组件初始化
        self.task_generator: LLMAPI = initialize_llm(TASK_PROMPT)

        # Why doing so?
        # sd内部有llm
        self.sd: StableDiffusion = StableDiffusion()
        self.sd.initialize()

        # 任务队列
        self.task_queue = {}

        # 战斗队列
        self.battle_queue = {}

    def registerPlayer(self, name, email, password):
        """
        Add a new instance of Player in the DM.
        The name and the feature are firstly checked.
        ? Bro what are you doing?
        ! need double check.

        Args:
            name (str): The player name.
            email (str): The player email.
            password (str): The player password.

        Returns:
            bool: True if the registration is successful.
        """
        # 用户名和邮箱不得重复
        if name in self.player_dict:
            return False
        if email in self.player_dict2:
            return False

        dm_model: LLMAPI = initialize_llm(DM_PROMPT)
        equipment_generator: LLMAPI = initialize_llm(EQUIPMENT_PROMPT)
        skill_generator: LLMAPI = initialize_llm(SKILL_PROMPT)
        task_custom: LLMAPI = initialize_llm(CUSTOM_PROMPT)

        new_player: Player = Player(name, email, password, dm_model, equipment_generator, skill_generator, task_custom)

        with LOCK:
            # regist the user in the list.
            self.player_dict[name] = new_player
            self.player_dict2[email] = new_player
            self.online_player[name] = new_player

        return True

    def loginPlayer(self, email, password):
        """
        Login the player by using email and password...


        Args:
            email (str): the email to indentify the player.
            password (str): the password to indentify the player.

        Returns:
            str|None: the player'name if login successfully, or none if failed.
        """
        if email not in self.player_dict2.keys():
            return None

        player: Player = self.player_dict2[email]

        if password != player.password:
            return None
        else:
            with LOCK:
                self.online_player[player.name] = datetime.now()
            return player.name

    def refreshTaskQueue(self, num=3):
        """
        ? Why this name...
        Check and update the task queue, making the queue is full.

        Args:
            num (int, optional): the maximum task number. Defaults to 3.


        """
        task_type = list(TASK_DISTRIBUTION.keys())
        probabilities = list(TASK_DISTRIBUTION.values())

        # This really fucked up.
        for __ in range(num):
            chosen_item = random.choices(task_type, weights=probabilities, k=1)[0]
            task = self.taskGenerate(chosen_item)
            self.task_queue[task["task_name"]] = task

    def taskGenerate(self, 
                    task_type  : str,
                    description: str = "任意"): 
        """
        Generate a task based on the task type and description.

        Args:
            task_generator (LLMAPI): The task generator.
            task_type (str): the type of the task
            description (str, optional): The detailed description of the task. Defaults to "任意".

        Returns:
            dict{}: The information of generated task.
            {
                "task_name":（任务名称）
                "task_description":（任务描述)
                "attention":（注意事项）
                "reward":（任务报酬）
                "occupied":（是否被占用）
                "player":（占用者）
            }
        """
        need = f"帮我生成一个{description}的{task_type}"
        task = self.task_generator.generateResponse(need)
        task = json.loads(task)
        task["occupied"] = False
        task["player"] = None
        return task

    def taskCustomize(self, player_name: str, description="任意"):
        """
        Customize the task based on the description. Note that this task is private and not visible for other players.

        Args:
            player_name (str): the player name who asking the task.
            description (str, optional): the description of the task. Defaults to "任意".

        Returns:
            dict: the customized task information.
        """
        player: Player = self.player_dict[player_name]

        need = f"【玩家】帮我生成一个任务， 要求是{description}"
        task = player.task_custom.generateResponse(need)
        task = json.loads(task)

        player.personal_task_queue[task['task_name']] = task

        return task

    def getPlayerInput(self, 
                       player_name : str,
                       player_input: str,
                       mode        : int,
                       equipment   : list = [],
                       skill       : list = [],
                       roles       : list = []):
        """
        Get the player input and return the response from the system, including the dm and the director.

        Args:
            player_name (str): The name of the player.
            player_input (str): The input of the player.
            mode (int): the code to indicate the mode of the system. 
            0: Talking to DM.
            1: Talking to director.
            equipment (list, optional): The equipment of the player. Defaults to [].
            skill (list, optional): The skill of the player. Defaults to [].
            roles (list, optional): The previous NPCs appeared. Defaults to [].
        
        Returns:
            dict{}: the result from DM or director.

        Raises:
            ValueError: If the player is not found.

        ! How does writing like this helps...
        """
        debug_print(self.player_dict.keys())

        if player_name not in self.player_dict.keys():
            raise ValueError("Player not found")
        player: Player = self.player_dict[player_name]

        match mode:
            case 0:
                return player.talkToDM(player_input)
            case 1:
                # As you wish.
                player_use = player.organizePlayerUse(equipment, skill)
                judge, play = player.talkToDirector(player_input, player_use)
                debug_print('[debug]play:', judge, play)

                # Check if a new NPC appears. Say, generate a new NPC.
                if play["role"] and play["role"] not in roles:
                    debug_print("generating img...")
                    description = f"【场景】{play['text']}\n【需要描绘的角色】{play['role']}"
                    img = self.sd.standard_workflow(description, 1)
                    play["image_data"] = img

                # 游戏结束，进入结算
                elif play["status"] == 1:
                    task_name = player.leaveTask()
                    self.task_queue.pop(task_name)

                    rewards = play["reward"]
                    if rewards:
                        player.getReward(rewards)
                    play["image_data"] = None

                # 游戏正常进行且没有新角色
                else:
                    play["image_data"] = None

                return play

    def selectTask(self, player_name: str, task_name: str, mode: int):
        """
        Args:
            player_name (str): the player's name who chose the task.
            task_name (str): the task's name which is chosen.
            mode (int): public task(0) or personal task(1)

        ? How can you know this task is now yours? Weird.

        Returns:
            dict{}: the initial_scene generated by the director.

        Raises:
            ValueError: when the task is not avaliable.
        """
        debug_print(player_name, task_name)
        player: Player = self.player_dict[player_name]

        match mode:
            case 0:
                task = self.task_queue[task_name]
            case 1:
                task = player.personal_task_queue[task_name]

        play = str(task)
        task_img = self.sd.standard_workflow(play, 2)

        with LOCK:
            task["occupied"] = True
            task["player"] = player_name

        judge        : LLMAPI = initialize_llm(JUDGE_PROMPT)
        task_director: LLMAPI = initialize_llm(ACT_PROMPT)

        initial_scene = task_director.generateResponse(play)
        initial_scene = json.loads(initial_scene)
        initial_scene['image_data'] = task_img

        debug_print('start>', initial_scene)

        player.takeTask(task_director, judge, task_name)

        return initial_scene

    def getPlayerInfo(self, name):
        """
        To be exact, this returns the propoerty of the player.

        Args:
            name (str): the name of the player.

        Returns:
            dict{}: the property of the player.
        """
        if name in self.player_dict.keys():
            player: Player = self.player_dict[name]
            return player.property
        else:
            return None

    def craftItems(self, 
                   player_name: str,
                   mode: int,
                   num: int,
                   description: str):
        """
        
        To finally make some items to use.

        Either craft equipment or skill, function will register the result, and consume the property.

        Args:
            player_name (str): the player who is about to craft.
            mode (int): 0 for equipment, 1 for skill.
            num (int): the number of resources the player is willing to use.
            description (str): the description of the expected item.

        Returns:
            str|dict: Neither the information of why failed, or the real information dict for equipment/skill
        """
        if player_name in self.player_dict.keys():
            player: Player = self.player_dict[player_name]

        if description == "":
            return "Error"

        if mode == 0:
            if not player.consumeProperty('凤羽', num):
                return "您的凤羽储量不足，请不要为难我，勇士！"
            
            request = f"{player_name}想要制作{description}的装备，对此玩家愿意投入 {num} 凤羽"
            response = player.equipment_generator.generateResponse(request)

            debug_print(response)

            response = fixResponse(response, "outlook")
            response = fixResponse(response, "description")
            equip = json.loads(response)
            player.bag[equip['name']] = equip
            return equip

        elif mode == 1:
            if not player.consumeProperty('龙眼', num):
                return "您的龙眼储量不足，请不要为难我，勇士！"
            
            request = f"【请求之人】{player_name} 需要一个{description}的技能，对此我愿意投入{num}个龙眼。"
            response = player.skill_generator.generateResponse(request)

            debug_print(response)

            skill = json.loads(fixResponse(response, "effect"))
            player.skills[skill['name']] = skill

            return skill
        
        else:
            return "Unknown mode"

    def getAllAvailableTasks(self):
        """
        Return all the tasks that are available for public.

        Returns:
            List[str]: the result.
        """
        tasks = [task["task_name"] for task in self.task_queue.values() if task["occupied"] is False]

        return tasks

    def getAllAvailablePersonalTasks(self, player_name):
        """
        return all the tasks that are private, and also not occupied...

        Args:
            player_name (str): the player name...

        Returns:
            List[str]: the result.
        """
        player: Player = self.player_dict[player_name]
        tasks = [task["task_name"] for task in player.personal_task_queue.values()]

        return tasks
    
    def getAllOnlinePlayers(self):
        """
        Return all the online players.
        """

        result = list(self.online_player.keys())
        return result

    def createBattle(self, player1, player2):
        battle_id = player1+player2
        player_role1: Player = self.player_dict[player1]
        player_role2: Player = self.player_dict[player2]
        new_battle: Battle = Battle(player1, player2, player_role1, player_role2, battle_id)
        with LOCK:
            self.battle_queue[battle_id] = new_battle

        player_role1: Player = self.player_dict[player1]
        player_role2: Player = self.player_dict[player2]

        player_role1.challenge_queue[battle_id] = {
            'challenger': player1,
            'target': player2,
            'status': 0
        }
        player_role2.challenge_queue[battle_id] = {
            'challenger': player1,
            'target': player2,
            'status': 0
        }
        return battle_id

    def acceptBattle(self, player, battle_id):
        try:
            with LOCK:
                battle_sys: LLMAPI = initialize_llm(BATTLE_PROMPT)
                battle: Battle = self.battle_queue[battle_id]

                battle.status = 1
                battle.sys = battle_sys

                battle.challenger_role.challenge_queue[battle_id]['status'] = 1
                battle.target_role.challenge_queue[battle_id]['status'] = 1
            return 200
        except:
            return 404

    def rejectBattle(self, player, battle_id):
        try:
            battle: Battle = self.battle_queue[battle_id]
            with LOCK:
                battle.status = 2
                self.battle_queue.pop(battle_id)

            battle.challenger_role.challenge_queue.pop(battle_id)
            battle.target_role.challenge_queue.pop(battle_id)
            return 200
        except:
            return 404

    def playerBattle(self, battle_id: str, player: str, player_input: str, equipment: list, skill: list):

        player_role: Player = self.player_dict[player]
        battle: Battle = self.battle_queue[battle_id]
        battle_status = False

        player_status = player_role.organizePlayerUse(equipment, skill)

        with LOCK:
            if DEBUG:
                print(f"player{player} has input!")
                print("battle_id:", id(battle))
            battle.now_round['details'][player] = {'action': player_input, 'status': player_status}
            if DEBUG:
                for k, v in battle.now_round.items():
                    print(k)
                    print(v)

            opponent = battle.pair[player]

            if opponent in battle.now_round['details']:
                fight = battle.now_round['details']
                des, battle_status = battle.directFight(player)

                if DEBUG:
                    print('successful round!')
                    print(opponent, fight[opponent], des, battle_status)

                return opponent, fight[opponent]['action'], des, battle_status

            return opponent, "正在出招", "请耐心等待对手", battle_status

    def getOnlinePlayers(self):
        return list(self.online_player.keys())

    def onlineConfirm(self, player: str):
        with LOCK:
            self.online_player[player] = datetime.now()

    def getChallengeList(self, player: str):
        player_role: Player = self.player_dict[player]
        # 别人挑战我
        id_list = []
        role_list = []

        # 我挑战别人
        accept_id = []

        try:
            for battle_id, battle_info in player_role.challenge_queue.items():
                if battle_info['target'] == player and battle_info['status'] == 0:
                    id_list.append(battle_id)
                    role_list.append(battle_info['challenger'])

                if battle_info['status'] == 1 and battle_info['challenger'] == player:
                    with LOCK:
                        player_role.challenge_queue[battle_id]['status'] = 3  # 已经接受过
                    accept_id.append(battle_id)
        except:
            id_list = []
            role_list = []
            accept_id = []
        return id_list, role_list, accept_id

    def getBattleInfo(self, player: str, battle_id: str):
        status = False
        try:
            battle: Battle = self.battle_queue[battle_id]
            if battle.status == 4 or battle.status == 5:
                status = True
            if battle.last_round[player] == 0:
                battle.last_round[player] = 1
                return (battle.pair[player],
                        battle.last_round['details'][battle.pair[player]]['action'],
                        battle.last_round['details']['sys'],
                        status)
            else:
                return None, None, None, status

        except:
            return None, None, None, status


# 负责管理后台系统
class MultiThreadManager:
    def __init__(self, backend_sys: BackEndSystem):
        self.backend_sys: BackEndSystem = backend_sys

        self.threads = []
        self.running = True
        self.lock = threading.Lock()

        # 创建并启动任务监控线程
        self.create_and_start_thread(self.refresh_task_queue, "TaskQueueMonitorThread")

        # 创建并启动玩家信息保存线程
        self.create_and_start_thread(self.save_player_info, "PlayerInfoSaveThread")

        # 创建玩家离线线程
        self.create_and_start_thread(self.clear_offline_players, "OfflinePlayerClearThread")

        # 创建并启动战斗队列管理线程
        self.create_and_start_thread(self.clear_disabled_battle, "BattleQueueClearThread")

    def create_and_start_thread(self, target, name):
        thread = threading.Thread(target=target, name=name)
        thread.start()
        self.threads.append(thread)

    # 每隔600秒检查一次任务队列，如果小于3就会自动补充
    def refresh_task_queue(self, max_size=3):
        while self.running:
            try:
                existed_task_num = len(self.backend_sys.task_queue)
                if existed_task_num < max_size:
                    new_task_num = max_size - existed_task_num
                    self.backend_sys.refreshTaskQueue(new_task_num)
                    print(
                        f"公共任务数量少于{max_size}，已添加{new_task_num}个任务。当前队列大小：{len(self.backend_sys.task_queue)}")
            except Exception as e:
                print(f"Error in refresh_task_queue: {e}")
            time.sleep(600)

    def save_player_info(self):
        while self.running:
            try:
                if not os.path.isdir('./saves'):
                    os.makedirs('./saves')
                auto_save_num = 0
                for name, info in self.backend_sys.online_player.items():
                    filename = f'./saves/{name}.pkl'
                    with open(filename, 'wb') as file:
                        pickle.dump(self.backend_sys.player_dict[name], file)
                    auto_save_num += 1
                print(f"成功保存 {auto_save_num} 个在线用户的信息")
            except Exception as e:
                print(f"Error in save_player_info: {e}")
            time.sleep(300)

    def clear_offline_players(self):
        while self.running:
            try:
                online_players = list(self.backend_sys.online_player.keys())
                time_now = datetime.now()
                for name in online_players:
                    if time_now - self.backend_sys.online_player[name] > timedelta(seconds=30):
                        with self.lock:
                            last_time = self.backend_sys.online_player.pop(name)

                        player: Player = self.backend_sys.player_dict[name]
                        for battle_id in player.challenge_queue.keys():
                            battle: Battle = self.backend_sys.battle_queue[battle_id]
                            battle.last_round['details']['sys'] = f"玩家【{name}】逃跑了。"
                            battle.status = 5

                        if not os.path.isdir('./saves'):
                            os.makedirs('./saves')
                        filename = f'./saves/{name}.pkl'
                        with open(filename, 'wb') as file:
                            pickle.dump(self.backend_sys.player_dict[name], file)
                        print(f"玩家 【{name}】 下线了. 最近一次在线时间为: {last_time}")
            except Exception as e:
                print(f"Error in clear_offline_players: {e}")
            time.sleep(30)

    def clear_disabled_battle(self):
        while self.running:
            try:
                existing_battle = list(self.backend_sys.battle_queue.keys())
                for battle_id in existing_battle:
                    if ((self.backend_sys.battle_queue[battle_id].status == 0 and
                            datetime.now() - self.backend_sys.battle_queue[battle_id].create_time > timedelta(
                                minutes=1)) or
                            (self.backend_sys.battle_queue[battle_id].status == 5)):
                        moved_battle: Battle = self.backend_sys.battle_queue.pop(battle_id)

                        moved_battle.challenger_role.challenge_queue.pop(battle_id)
                        moved_battle.target_role.challenge_queue.pop(battle_id)
                        print(f"移除了战斗 “{battle_id}”, 发起时间为{moved_battle.create_time}")
                        del moved_battle  # 显式删除引用

            except Exception as e:
                print(f"Error in clear_rejected_battle: {e}")
            time.sleep(60)

    def stop(self):
        self.running = False
        for thread in self.threads:
            thread.join()